<?php

/**
 * @file
 * Contains custom code for Senators and their Microsite Content.
 */

use Drupal\block_content\Entity\BlockContent;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Access\AccessResultAllowed;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\pathauto\Entity\PathautoPattern;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\TermInterface;
use Drupal\user\Entity\User;
use Drupal\user\UserInterface;

/**
 * Implements hook_theme().
 */
function nys_senators_theme($existing, $type, $theme, $path) {
  return [
    'senator_microsite_menu_block' => [
      'variables' => ['menu_links' => NULL],
    ],
  ];
}

/**
 * Implements hook_node_grants().
 *
 * This function assigns group flags (grants) to users for access to content.
 */
function nys_senators_node_grants(AccountInterface $account, $op) {

  // Initialize empty grants array for return.
  $grants = [];

  // Group 1 will represent all users.
  // Microsite Users wil be non senator specific.
  $grants['microsite_users'][] = 1;

  // Define role checks as arrays to expand upon in the future as needed.
  // What editorial roles need any level edit access.
  $granted_member_roles = [
    'microsite_content_producer',
    'administrator',
    'content_admin',
  ];

  // What administrative roles need non-senator based edit access.
  $admin_roles = [
    'content_admin',
    'administrator',
  ];

  // Fetch the User's roles.
  $user_roles = $account->getRoles();

  // First check if authenticated.
  // Second check if they are a role we want to give Microsite edit access to.
  if ($account->isAuthenticated() && !empty(array_intersect($granted_member_roles, $user_roles))) {

    // If user is an admin we need to give full access to the content.
    if (!empty(array_intersect($admin_roles, $user_roles))) {

      // User is an Admin. Grant access to all microsite content.
      // Group 2 will be a representation of our admins.
      $grants['microsite_users'][] = 2;
    }
    else {

      // The User falls within a Senator based producer.
      // Find out all of the User's senators. To do so, load user entity.
      $user = User::load($account->id());

      // Make sure the user has the field and that there is a value.
      if ($user->hasField('field_senator_multiref') && !empty($senators = $user->field_senator_multiref->getValue())) {

        // There is a potential for multiple senators so run through each.
        foreach ($senators as $senator) {

          // Grant access to producers group based on Senator ID.
          $grants['microsite_producers'][] = $senator['target_id'];
        }
      }
    }
  }

  // Return any grants we have assigned.
  return $grants;
}

/**
 * Implements hook_node_access_records().
 */
function nys_senators_node_access_records(NodeInterface $node) {

  // Initialize empty access array for return.
  $access = [];

  // Build an array of microsite content types we care about.
  $microsite_cts = [
    'article',
    'event',
    'petition',
    'microsite_page',
  ];

  // If the node is in a bundle that could be microsite content.
  if (in_array($node->bundle(), $microsite_cts, TRUE)) {

    // Add the appropriate gids to the proper realms for each level of access.
    // Start with all and administrative users.
    // All users access view if published.
    if ($node->isPublished()) {

      $access[] = [
        'realm' => 'microsite_users',
        'gid' => 1,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      ];
    }

    // Add in Crud operations for Admins.
    $access[] = [
      'realm' => 'microsite_users',
      'gid' => 2,
      'grant_view' => 1,
      'grant_update' => 1,
      'grant_delete' => 1,
      'priority' => 0,
    ];

    // Now check for a filled out Senator field.
    if ($node->hasField('field_senator_multiref') && !empty($senators = $node->field_senator_multiref->getValue())) {

      // For all Senators on Node, grant producers access based on Senator.
      foreach ($senators as $senator) {

        // Add edit access to producers based on Senator ID.
        $access[] = [
          'realm' => 'microsite_producers',
          'gid' => $senator['target_id'],
          'grant_view' => 1,
          'grant_update' => 1,
          'grant_delete' => 0,
          'priority' => 0,
        ];
      }
    }
  }

  // Return access records added.
  return $access;
}

/**
 * Implements hook_entity_access().
 */
function nys_senators_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {

  // Only fire when updating a Senator Term.
  if ($entity->getEntityType()->id() === 'taxonomy_term' && $entity->bundle() === 'senator' && $operation === 'update') {

    // Fetch the User's roles.
    $user_roles = $account->getRoles();

    // What administrative roles need checking.
    $admin_roles = [
      'content_admin',
      'administrator',
    ];

    // Only check for MCPs.
    if (in_array('microsite_content_producer', $user_roles, FALSE) && empty(array_intersect($admin_roles, $user_roles))) {

      // The User falls within a Senator based producer.
      // Find out all of the User's senators. To do so, load user entity.
      $user = User::load($account->id());

      // Make sure the user has the field and that there is a value.
      if ($user->hasField('field_senator_multiref') && !empty($senators = array_column($user->field_senator_multiref->getValue(), 'target_id'))) {

        // Lastly check if term is in MCPs senator values.
        if (in_array($entity->id(), $senators, FALSE)) {

          // Matched value. You shall pass.
          return AccessResultAllowed::allowed()->setCacheMaxAge(0);
        }
      }

      // Either they don't have a senator or not the right Senator.
      return AccessResult::forbidden()->setCacheMaxAge(0);
    }
  }

  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_entity_presave().
 */
function nys_senators_user_presave(UserInterface $user) {
  // Fetch the User's roles.
  $user_roles = $user->getRoles();
  // Only check for MCPs.
  if (!in_array('microsite_content_producer', $user_roles, FALSE)) {
    if ($user->hasField('field_senator_multiref')) {
      $user->set('field_senator_multiref', 0);
    }
  }
}

/**
 * Implements hook_form_node_form_alter().
 */
function nys_senators_form_node_form_alter(&$form, $form_state) {
  $user = \Drupal::currentUser();
  $user = User::load($user->id());
  // Fetch the User's roles.
  $user_roles = $user->getRoles();
  // Disable the senator in case the MCP user has one senator and allows select
  // the senator in case MCP has more than one assigned
  // Also enable Admin user to select any senator even when it is not assigned.
  if (in_array('microsite_content_producer', $user_roles, FALSE) && !in_array('administrator', $user_roles, FALSE)) {
    if ($user->hasField('field_senator_multiref') && count($user->field_senator_multiref->getValue()) == 1) {
      $form['field_senator_multiref']['#disabled'] = TRUE;
      $form['field_senator_multiref']['widget']['#default_value'] = array_column($user->field_senator_multiref->getValue(), 'target_id');
    }
    $targets = array_column($user->field_senator_multiref->getValue(), 'target_id');
    $options = $form['field_senator_multiref']['widget']['#options'];
    $result = [];
    foreach ($options as $key => $option) {
      if ($key == '_none' || in_array($key, $targets)) {
        $result[$key] = $option;
      }
    }
    $form['field_senator_multiref']['widget']['#options'] = $result;
  }
}

/**
 * Implements hook_form_alter().
 */
function nys_senators_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'block_content_microsite_hero_form') {
    $user = \Drupal::currentUser();
    $user = User::load($user->id());
    $user_roles = $user->getRoles();
    if (in_array('microsite_content_producer', $user_roles, FALSE) && !in_array('administrator', $user_roles, FALSE)) {
      if ($user->hasField('field_senator_multiref') && count($user->field_senator_multiref->getValue()) == 1) {
        $form['field_senator']['#disabled'] = TRUE;
        $form['field_senator']['widget']['#default_value'] = array_column($user->field_senator_multiref->getValue(), 'target_id');
      }
      $targets = array_column($user->field_senator_multiref->getValue(), 'target_id');
      $options = $form['field_senator']['widget']['#options'];
      $result = [];
      foreach ($options as $key => $option) {
        if ($key == '_none' || in_array($key, $targets)) {
          $result[$key] = $option;
        }
      }
      $form['field_senator']['widget']['#options'] = $result;
    }
  }
}

/**
 * Creates senator microsites pages.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity interface.
 *
 * @throws \Drupal\Core\Entity\EntityStorageException
 */
function _nys_senators_create_senator_microsites(EntityInterface $entity) {
  // Gets the senator name value.
  $senator_name = $entity->label();

  // Creates hero block to be attached to the microsite content.
  $heroBlock = BlockContent::create([
    'info' => $senator_name . ' - Hero block',
    'type' => 'microsite_hero',
    'revision_user' => 1,
    'field_senator' => [
      'target_id' => $entity->id(),
    ],
  ]);
  $heroBlock->save();

  // Creates menu block to be attached to the microsite content.
  $menuBlock = BlockContent::create([
    'info' => $senator_name . ' - Menu block',
    'type' => 'senator_microsite_menu',
    'revision_user' => 1,
  ]);
  $menuBlock->save();

  // Loads microsite page type terms.
  $termEntityManager = \Drupal::service('entity_type.manager')->getStorage('taxonomy_term');
  $micrositeTypes = $termEntityManager->loadByProperties([
    'vid' => 'microsite_page_type',
  ]);

  // Iterates through each microsite term and creates the microsite page.
  foreach ($micrositeTypes as $micrositeType) {
    if ($micrositeType->getName() !== 'Inactive') {
      // Default node values.
      $nodeValues = [
        'type' => 'microsite_page',
        'status' => 1,
        'uid' => 1,
        'field_microsite_page_type' => [
          'target_id' => $micrositeType->id(),
        ],
        'field_block' => [
          [
            'target_id' => $heroBlock->id(),
            'target_revision_id' => $heroBlock->getRevisionId(),
          ],
          [
            'target_id' => $menuBlock->id(),
            'target_revision_id' => $menuBlock->getRevisionId(),
          ],
        ],
        'field_senator_multiref' => [
          [
            'target_id' => $entity->id(),
          ],
        ],
      ];

      // Sets the node title value considering the microsite page we are
      // creating.
      switch ($micrositeType->getName()) {
        case 'Landing':
          $nodeValues['title'] = $senator_name;
          break;

        case 'About':
        case 'Newsroom':
        case 'Legislation':
        case 'Events':
          // @todo Add extra title logic if needed.
          $nodeValues['title'] = 'About ' . $senator_name;
          break;

        case 'Our District':
          $nodeValues['title'] = $micrositeType->getName();
          break;

        case 'Contact':
          $nodeValues['title'] = 'About ' . $senator_name;
          $senatorContactBlock = \Drupal::service('entity_type.manager')->getStorage('block_content')->loadByProperties([
            'type' => 'microsite_contact_webform',
            'status' => 1,
            'info' => 'Senator contact form - Microsite Contact block',
          ]);
          $senatorContactBlock = reset($senatorContactBlock);
          $nodeValues['field_block'][] = [
            'target_id' => $senatorContactBlock->id(),
            'target_revision_id' => $senatorContactBlock->getRevisionId(),
          ];
          break;

      }

      // Creates the new microsite page.
      $node = Node::create($nodeValues);
      $node->save();
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function nys_senators_taxonomy_term_insert(EntityInterface $entity) {
  // Acts on every new senator taxonomy term that's added.
  if ($entity->bundle() === 'senator') {
    _nys_senators_create_senator_microsites($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function nys_senators_taxonomy_term_update(EntityInterface $entity) {
  /** @var \Drupal\taxonomy\Entity\Term $term */
  $term = $entity;
  // Acts on every new senator taxonomy term that's updated.
  if ($term->bundle() === 'senator' &&
    $term->get('field_active_senator')->value === 0) {
    // Sets currentTid variable from the term.
    $currentTid = $entity->id();

    // Looks for the Microsite pages that are referencing this senator.
    $pages = \Drupal::entityQuery('node')
      ->accessCheck(FALSE)
      ->condition('type', 'microsite_page')
      ->condition('field_senator_multiref', [$currentTid], 'IN')
      ->execute();

    // Checks if there are results or not.
    if (!empty($pages)) {
      // Loads the microsite pages found.
      $nodes = Node::loadMultiple($pages);

      // Unpublishes each senator microsite page.
      foreach ($nodes as $node) {
        if ($node->isPublished()) {
          $node->set('status', '0');
          if ($node->hasField('field_microsite_page_type') && !$node->get('field_microsite_page_type')->isEmpty()) {
            $tid = $node->field_microsite_page_type->getValue()[0]['target_id'] ?? '';
            $term = Term::load($tid);
            if ($term instanceof TermInterface && !empty($term->getName()) && $term->getName() === 'Landing') {
              $aliasEntity = \Drupal::entityTypeManager()->getStorage('path_alias')->loadByProperties([
                'path' => '/node/' . $node->id(),
              ]);
              $aliasEntity = reset($aliasEntity);
              $aliasEntity->set('alias', $aliasEntity->get('alias')->value . '/landing');
              $aliasEntity->save();
            }
          }
          $node->save();
        }
      }
    }

    // Loads the Inactive term.
    $inactiveTerm = \Drupal::service('entity_type.manager')->getStorage('taxonomy_term')->loadByProperties([
      'vid' => 'microsite_page_type',
      'name' => 'Inactive',
    ]);
    $inactiveTerm = reset($inactiveTerm);

    // Creates hero block to be attached to the microsite content.
    $heroBlock = BlockContent::create([
      'info' => $entity->label() . ' - Hero block',
      'type' => 'microsite_hero',
      'revision_user' => 1,
      'field_senator' => [
        'target_id' => $entity->id(),
      ],
    ]);
    $heroBlock->save();

    // Creates inactive senator block to be attached to the microsite content.
    $inactiveSenatorBlock = BlockContent::create([
      'info' => $entity->label() . ' - Inactive block',
      'type' => 'inactive_senator_block',
      'revision_user' => 1,
    ]);
    $inactiveSenatorBlock->save();

    // Inactive Microsite page node values.
    $nodeValues = [
      'type' => 'microsite_page',
      'status' => 1,
      'uid' => 1,
      'title' => $entity->label(),
      'field_microsite_page_type' => [
        'target_id' => $inactiveTerm->id(),
      ],
      'field_block' => [
        [
          'target_id' => $heroBlock->id(),
          'target_revision_id' => $heroBlock->getRevisionId(),
        ],
        [
          'target_id' => $inactiveSenatorBlock->id(),
          'target_revision_id' => $inactiveSenatorBlock->getRevisionId(),
        ],
      ],
      'field_senator_multiref' => [
        [
          'target_id' => $currentTid,
        ],
      ],
    ];

    // Creates the new microsite page.
    $node = Node::create($nodeValues);
    $node->save();
  }
}

/**
 * Implements hook_pathauto_pattern_alter().
 */
function nys_senators_pathauto_pattern_alter(PathautoPattern &$pattern, array $context) {
  // When nodes are created or updated, alter pattern with criteria logic.
  if ($context['module'] === 'node'
    && $context['bundle'] === 'microsite_page'
    && ($context['op'] === 'insert' || $context['op'] === 'update')) {
    /** @var \Drupal\node\Entity\Node $node */
    $node = $context['data']['node'];

    $replacements = [];
    if ($node->hasField('field_microsite_page_type') && !$node->get('field_microsite_page_type')->isEmpty()) {
      $tid = $node->field_microsite_page_type->getValue()[0]['target_id'] ?? '';
      $term = Term::load($tid);
      if ($term instanceof TermInterface && !empty($term->getName())) {
        switch ($term->getName()) {
          case 'Landing':
          case 'Inactive':
            // Workaround to allow nys_senators_taxonomy_term_update update
            // Senator Landing alias.
            if (($term->getName() === 'Landing' && $context['op'] !== 'update')
                || $term->getName() === 'Inactive') {
              $replacements[] = '';
            }
            break;

          case 'About':
          case 'Newsroom':
          case 'Legislation':
          case 'Contact':
            // @todo Add extra logic if needed.
            break;

          case 'Our District':
            $replacements[] = 'district';
            break;

          case 'Events':
            $replacements[] = 'calendar';
            break;

        }
      }
    }

    if ($replacements) {
      $replacements = implode('/', $replacements);

      // Replace default "[node:field_microsite_page_type:entity:name]" with
      // the dynamic pattern set before in the replacements array.
      $pattern->setPattern(preg_replace('/\[node:field_microsite_page_type:entity:name\]/', $replacements . '$1', $pattern->getPattern()));
    }
  }
}

/**
 * Implements hook_token_info().
 */
function nys_senators_token_info() {
  // Adds current page senator name token.
  $info['tokens']['current-page']['senator-name'] = [
    'name' => t('Current Page Senator name'),
    'description' => t('The current page senator name'),
    'needs-data' => 'node',
  ];

  // Adds current page senator TID token.
  $info['tokens']['current-page']['senator-tid'] = [
    'name' => t('Current Page Senator TID'),
    'description' => t('The current page senator TID'),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 */
function nys_senators_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type === 'current-page') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'senator-name':
          $node = \Drupal::routeMatch()->getParameter('node');
          if ($node instanceof NodeInterface
            && $node->hasField('field_senator_multiref')
            && !$node->get('field_senator_multiref')->isEmpty()) {
            $term = $node->field_senator_multiref->entity;
            $senator_name = ($term instanceof TermInterface && !empty($term->getName())) ? $term->getName() : '';
            $replacements[$original] = $senator_name;
          }
          break;

        case 'senator-tid':
          $node = \Drupal::routeMatch()->getParameter('node');
          if ($node instanceof NodeInterface
            && $node->hasField('field_senator_multiref')
            && !$node->get('field_senator_multiref')->isEmpty()) {
            $term = $node->field_senator_multiref->entity;
            $senator_tid = ($term instanceof TermInterface && !empty($term->id())) ? $term->id() : '';
            $replacements[$original] = $senator_tid;
          }
          break;

      }
    }
  }

  return $replacements;
}
